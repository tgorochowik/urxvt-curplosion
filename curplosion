#!/bin/perl

#author: tgorochowik@gmail.com

=head1 NAME

curplosion - don't know where your cursor is? explode it!

=head1 DESCRIPTION

Makes it easier to spot the cursor. The default trigger is  C-slash. To
change it, adjust the following setting:

  urxvt.curplosion.trigger: C-slash

Play with the following settings to adjust the looks of the curplosion:

  urxvt.curplosion.colors:    3, 4, 7
  urxvt.curplosion.sizes:     3, 5, 7, 9

Additionally, the duration of the curplosion can be adjusted:

  urxvt.curplosion.duration:  200

The unit of the duration is a millisecond. Also please note, that if
the duration is set to a very small value, then the terminal might not
be able to process it fast enough, and it will last much longer. The
curplosion does NOT block the terminal, so setting it to a very large
value will not prevent any other usage of the terminal.

=cut

sub on_start {
  my ($self) = @_;

  # parse settings
  my $trigger  = $self->x_resource("%.trigger");
  my $colors   = $self->x_resource("%.colors");
  my $sizes    = $self->x_resource("%.sizes");
  my $duration = $self->x_resource("%.duration");

  # fallback to defaults
  defined $trigger  or $trigger  = "C-slash";
  defined $colors   or $colors   = "3, 4, 7";
  defined $sizes    or $sizes    = "3, 5, 7, 9";
  defined $duration or $duration = "200";

  # set trigger
  $self->parse_keysym($trigger, "perl:curplosion.curplode");

  # store other settings
  @{$self->{colors}} = split ", ", $colors;
  @{$self->{sizes}}  = split ", ", $sizes;

  # calculate a single delay based on other settings
  $self->{delay} = ($duration/1000.0)/(@{$self->{colors}} * @{$self->{sizes}});
}

sub on_user_command {
  my ($self, $string) = @_;

  if ($string =~ /curplode$/) {
    # check against nesting
    if (defined $self->{curplode_hooks}) {
      return;
    }

    # get position
    my ($row, $col) = $self->screen_cur;

    # generate animation steps
    foreach my $c (@{$self->{colors}}) {
      foreach my $f (@{$self->{sizes}}) {
        # check limits
        while ( ($f - 1)/2 > $col){ $col++;}
        while ( $col + ($f - 1)/2 >= $self->ncol){ $col--;}
        # accept step
        push @{$self->{curplode_steps}}, { size => $f, color => $c };
      }
    }

    # store position
    @{$self->{curplode_pos}} = ($row, $col);

    # assign hooks
    $self->{'curplode_hooks'} = $self->on(refresh_begin => sub {incinerate $self},
                                          refresh_end   => sub {extinguish $self});

    # trigger animation
    $self->want_refresh;
  }
}

sub fire {
  my ($self, $row, $col, $size, $color) = @_;
  return $self->ROW_r($row, [(urxvt::SET_COLOR(urxvt::DEFAULT_RSTYLE, $color, $color)) x $size], $col - ($size-1)/2);
}

sub incinerate {
  my ($self) = @_;

  if ( @{$self->{curplode_steps}} > 0) {
    my ($row, $col) = @{$self->{curplode_pos}};

    my $size  = $self->{curplode_steps}[0]{size};
    my $color = $self->{curplode_steps}[0]{color};

    $self->{curplode_ur} = fire $self, $row - 1, $col, $size, $color;
    $self->{curplode_cr} = fire $self, $row,     $col, $size, $color;
    $self->{curplode_lr} = fire $self, $row + 1, $col, $size, $color;
  } else {
    delete @{$self}{grep /^curplode_/, keys %$self};
  }
}

sub extinguish {
  my ($self) = @_;

  if ( @{$self->{curplode_steps}} > 0) {
    my ($row, $col) = @{$self->{curplode_pos}};

    my $step = $self->{curplode_steps}[0];

    $self->ROW_r ($row - 1, delete $self->{curplode_ur});
    $self->ROW_r ($row,     delete $self->{curplode_cr});
    $self->ROW_r ($row + 1, delete $self->{curplode_lr});

    # schedule next step
    $self->{curplode_next} = urxvt::timer
                             ->new
                             ->cb (sub {
                               shift @{$self->{curplode_steps}};
                               $self->want_refresh;
                             })
                             ->after($self->{delay});
  }
}
