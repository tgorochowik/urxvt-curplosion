#!/bin/perl

#author: tgorochowik@gmail.com

=head1 NAME

curplosion - don't know where your cursor is? explode it!

=head1 DESCRIPTION

Makes it easier to spot the cursor. The default trigger is  C-slash. To
change it, adjust the following setting:

  urxvt.curplosion.trigger: C-slash

=cut

sub on_start {
  my ($self) = @_;

  # parse settings
  my $trigger = $self->x_resource("%.trigger");

  # fallback to defaults
  defined $trigger or $trigger = "C-slash";

  # set trigger
  $self->parse_keysym($trigger, "perl:curplosion.curplode");
}

sub on_user_command {
  my ($self, $string) = @_;

  if ($string =~ /curplode$/) {
    # check against nesting
    if (defined $self->{curplode_hooks}) {
      return;
    }

    # define animation
    my @colors = (3, 4, 7);
    my @fires = (3, 5, 7, 9);

    # get position
    my ($row, $col) = $self->screen_cur;

    # generate animation steps
    foreach my $c (@colors) {
      foreach my $f (@fires) {
        # check limits
        while ( ($f - 1)/2 > $col){ $col++;}
        while ( $col + ($f - 1)/2 >= $self->ncol){ $col--;}
        # accept step
        push @{$self->{curplode_steps}}, { size => $f, color => $c };
      }
    }

    # store position
    @{$self->{curplode_pos}} = ($row, $col);

    # assign hooks
    $self->{'curplode_hooks'} = $self->on(refresh_begin => sub {incinerate $self},
                                          refresh_end   => sub {extinguish $self});

    # trigger animation
    $self->want_refresh;
  }
}

sub fire {
  my ($self, $row, $col, $size, $color) = @_;
  return $self->ROW_r($row, [(urxvt::SET_COLOR(urxvt::DEFAULT_RSTYLE, $color, $color)) x $size], $col - ($size-1)/2);
}

sub incinerate {
  my ($self) = @_;

  if ( @{$self->{curplode_steps}} > 0) {
    my ($row, $col) = @{$self->{curplode_pos}};

    my $size  = $self->{curplode_steps}[0]{size};
    my $color = $self->{curplode_steps}[0]{color};

    $self->{curplode_ur} = fire $self, $row - 1, $col, $size, $color;
    $self->{curplode_cr} = fire $self, $row,     $col, $size, $color;
    $self->{curplode_lr} = fire $self, $row + 1, $col, $size, $color;
  } else {
    delete @{$self}{grep /^curplode_/, keys %$self};
  }
}

sub extinguish {
  my ($self) = @_;

  if ( @{$self->{curplode_steps}} > 0) {
    my ($row, $col) = @{$self->{curplode_pos}};

    my $step = $self->{curplode_steps}[0];

    $self->ROW_r ($row - 1, delete $self->{curplode_ur});
    $self->ROW_r ($row,     delete $self->{curplode_cr});
    $self->ROW_r ($row + 1, delete $self->{curplode_lr});

    # schedule next step
    $self->{curplode_next} = urxvt::timer
                             ->new
                             ->cb (sub {
                               shift @{$self->{curplode_steps}};
                               $self->want_refresh;
                             })
                             ->after(0.005);
  }
}
